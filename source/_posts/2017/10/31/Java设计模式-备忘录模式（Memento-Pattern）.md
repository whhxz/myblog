---
title: Java设计模式-备忘录模式（Memento Pattern）
date: 2017-10-31 08:59:47
categories: ['设计模式']
tags: ['设计模式', '备忘录模式', 'Memento Pattern']
---

### 备忘录模式
> 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。

备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，当前很多软件都提供了撤销(Undo)操作，其中就使用了备忘录模式。

备忘录模式的核心是备忘录类以及用于管理备忘录的负责人类的设计，UML类图如下：
![](http://otxnth5wx.bkt.clouddn.com/20171102屏幕快照2017-10-31上午9.22.13.png)<!-- more -->
```java
/**
 * 原发器
 */
class Originator{
    private String state;

    /**
     * 备份还原
     * @param memento
     */
    public void restoreMemento(Memento memento){
        this.state = memento.getState();
    }
    /**
     * 创建备份
     * @return
     */
    public Memento createMemento(){
        return new Memento(state);
    }
}

/**
 * 备忘录
 */
class Memento{
    /**
     * 备份状态，这里是保存备忘录对应状态，可以采用原型模式
     */
    private String state;

    /**
     * 创建备忘录
     * 为了避免备忘录被其他不相干类使用，构造函数权限为默认，只允许同一个包调用，或者设置类为默认权限
     * @param state
     */
    Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}

/**
 * 备忘录负责人
 */
class Caretaker{
    //存储的备忘录只能还原一次，可以设计为集合或者链表
    private Memento memento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
```
* Originator（原发器）：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。
* Memento（备忘录)：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同。
* Caretaker（负责人）：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。

在下棋时，有时需要悔棋操作，可以采用备忘录设计模式：范例省略

### 备忘录总结
在使用备忘录模式时和命令模式结合可以达到很好的效果，如：在每次接收命令时，存储当前状态，之后如果业务需要回滚，可以通过备忘录回滚到指定状态。备忘录可以方便和原型模式使用，需要记录备忘录的时候直接克隆当前对象。

**适用场景：**
* 保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。
* 防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。

**优点：**
* 它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。
* 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。

**缺点：**
* 资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。
